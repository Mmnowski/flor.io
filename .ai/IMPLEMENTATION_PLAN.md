# Flor.io Implementation Plan

## Project Context

Building Flor.io - a plant care web application with AI-powered plant identification and care instructions. This is an MVP focused on helping users track watering schedules and manage their plant collection.

**Tech Stack:**

- React Router v7 (SSR enabled)
- Supabase (PostgreSQL + Auth + Storage)
- TailwindCSS v4 + shadcn/ui components
- PlantNet API (mocked initially)
- OpenAI GPT-5 API (mocked initially)
- Vitest for unit tests

**Implementation Strategy:**

- Priority: Technical dependency order
- Start from fresh create-react-router template
- Build foundational layers first, then features
- Mock external APIs initially
- Server-side image processing

---

## High-Level Implementation Phases

### Phase 1: Foundation & Infrastructure (Week 1-2)

Set up database schema, authentication, environment configuration, and core UI components.

### Phase 2: Core Plant Management (Week 3-4)

Implement manual plant card CRUD operations, image upload/storage, and basic dashboard.

### Phase 3: Watering System (Week 5-6)

Build watering tracking, notifications modal, and watering history.

### Phase 4: AI Integration (Week 7-9)

Implement AI-powered plant identification and care instruction generation (with mocks).

### Phase 5: Organization & Polish (Week 10-11)

Add rooms/filtering, usage limits, accessibility audit, and refinements.

### Phase 6: Testing & Optimization (Week 12-14)

Unit tests, performance optimization, bug fixes, and documentation.

---

## Database Schema Design

### SQL Schema for Supabase

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table (handled by Supabase Auth, but we reference it)
-- auth.users table exists by default

-- Rooms table
CREATE TABLE rooms (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, name)
);

-- Plants table
CREATE TABLE plants (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  photo_url TEXT, -- Supabase Storage URL
  watering_frequency_days INTEGER NOT NULL, -- e.g., 7
  room_id UUID REFERENCES rooms(id) ON DELETE SET NULL,

  -- Care instructions (generated by AI or manual)
  light_requirements TEXT,
  fertilizing_tips TEXT, -- JSON array of strings
  pruning_tips TEXT, -- JSON array of strings
  troubleshooting TEXT, -- JSON array of strings

  -- Metadata
  created_with_ai BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Watering history table
CREATE TABLE watering_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  plant_id UUID NOT NULL REFERENCES plants(id) ON DELETE CASCADE,
  watered_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- AI feedback table
CREATE TABLE ai_feedback (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  plant_id UUID NOT NULL REFERENCES plants(id) ON DELETE CASCADE,
  feedback_type TEXT NOT NULL CHECK (feedback_type IN ('thumbs_up', 'thumbs_down')),
  comment TEXT,
  ai_response_snapshot JSONB, -- Store the AI response for future fine-tuning
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Usage tracking table (for limits)
CREATE TABLE usage_limits (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  ai_generations_this_month INTEGER DEFAULT 0,
  month_year TEXT NOT NULL, -- e.g., "2025-01"
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, month_year)
);

-- Indexes for performance
CREATE INDEX idx_plants_user_id ON plants(user_id);
CREATE INDEX idx_plants_room_id ON plants(room_id);
CREATE INDEX idx_watering_history_plant_id ON watering_history(plant_id);
CREATE INDEX idx_watering_history_watered_at ON watering_history(watered_at DESC);
CREATE INDEX idx_rooms_user_id ON rooms(user_id);
CREATE INDEX idx_ai_feedback_user_id ON ai_feedback(user_id);
CREATE INDEX idx_usage_limits_user_month ON usage_limits(user_id, month_year);

-- Row Level Security Policies
ALTER TABLE plants ENABLE ROW LEVEL SECURITY;
ALTER TABLE watering_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE rooms ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_feedback ENABLE ROW LEVEL SECURITY;
ALTER TABLE usage_limits ENABLE ROW LEVEL SECURITY;

-- Plants policies
CREATE POLICY "Users can view their own plants"
  ON plants FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own plants"
  ON plants FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own plants"
  ON plants FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own plants"
  ON plants FOR DELETE
  USING (auth.uid() = user_id);

-- Watering history policies
CREATE POLICY "Users can view their own watering history"
  ON watering_history FOR SELECT
  USING (EXISTS (
    SELECT 1 FROM plants
    WHERE plants.id = watering_history.plant_id
    AND plants.user_id = auth.uid()
  ));

CREATE POLICY "Users can insert their own watering history"
  ON watering_history FOR INSERT
  WITH CHECK (EXISTS (
    SELECT 1 FROM plants
    WHERE plants.id = watering_history.plant_id
    AND plants.user_id = auth.uid()
  ));

-- Rooms policies
CREATE POLICY "Users can view their own rooms"
  ON rooms FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own rooms"
  ON rooms FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own rooms"
  ON rooms FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own rooms"
  ON rooms FOR DELETE
  USING (auth.uid() = user_id);

-- AI feedback policies
CREATE POLICY "Users can view their own feedback"
  ON ai_feedback FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own feedback"
  ON ai_feedback FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- Usage limits policies
CREATE POLICY "Users can view their own usage limits"
  ON usage_limits FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own usage limits"
  ON usage_limits FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own usage limits"
  ON usage_limits FOR UPDATE
  USING (auth.uid() = user_id);

-- Function to calculate next watering date
CREATE OR REPLACE FUNCTION get_next_watering_date(
  p_plant_id UUID
) RETURNS TIMESTAMPTZ AS $$
DECLARE
  v_last_watered TIMESTAMPTZ;
  v_frequency INTEGER;
BEGIN
  -- Get the last watering date
  SELECT watered_at INTO v_last_watered
  FROM watering_history
  WHERE plant_id = p_plant_id
  ORDER BY watered_at DESC
  LIMIT 1;

  -- Get watering frequency
  SELECT watering_frequency_days INTO v_frequency
  FROM plants
  WHERE id = p_plant_id;

  -- If never watered, use plant creation date
  IF v_last_watered IS NULL THEN
    SELECT created_at INTO v_last_watered
    FROM plants
    WHERE id = p_plant_id;
  END IF;

  -- Calculate next watering date
  RETURN v_last_watered + (v_frequency || ' days')::INTERVAL;
END;
$$ LANGUAGE plpgsql;

-- Function to get plants needing water (for notifications)
CREATE OR REPLACE FUNCTION get_plants_needing_water(
  p_user_id UUID
) RETURNS TABLE (
  plant_id UUID,
  plant_name TEXT,
  photo_url TEXT,
  last_watered TIMESTAMPTZ,
  next_watering TIMESTAMPTZ,
  days_overdue INTEGER
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.name,
    p.photo_url,
    COALESCE(
      (SELECT wh.watered_at
       FROM watering_history wh
       WHERE wh.plant_id = p.id
       ORDER BY wh.watered_at DESC
       LIMIT 1),
      p.created_at
    ) as last_watered,
    get_next_watering_date(p.id) as next_watering,
    EXTRACT(DAY FROM NOW() - get_next_watering_date(p.id))::INTEGER as days_overdue
  FROM plants p
  WHERE p.user_id = p_user_id
    AND get_next_watering_date(p.id) <= NOW()
  ORDER BY days_overdue DESC;
END;
$$ LANGUAGE plpgsql;
```

### Supabase Storage Buckets

```sql
-- Create storage bucket for plant photos
INSERT INTO storage.buckets (id, name, public)
VALUES ('plant-photos', 'plant-photos', true);

-- Storage policies
CREATE POLICY "Users can upload their own plant photos"
  ON storage.objects FOR INSERT
  WITH CHECK (
    bucket_id = 'plant-photos' AND
    auth.uid()::text = (storage.foldername(name))[1]
  );

CREATE POLICY "Users can view their own plant photos"
  ON storage.objects FOR SELECT
  USING (
    bucket_id = 'plant-photos' AND
    auth.uid()::text = (storage.foldername(name))[1]
  );

CREATE POLICY "Users can delete their own plant photos"
  ON storage.objects FOR DELETE
  USING (
    bucket_id = 'plant-photos' AND
    auth.uid()::text = (storage.foldername(name))[1]
  );
```

---

## Detailed Implementation Breakdown

## Phase 1: Foundation & Infrastructure

### 1.1 Environment Setup

**Files to create/modify:**

- `.env.example`
- `.env` (gitignored)
- `app/lib/supabase.server.ts`
- `app/lib/supabase.client.ts`

**Tasks:**

1. Create environment variables structure:

   ```
   SUPABASE_URL=
   SUPABASE_ANON_KEY=
   SUPABASE_SERVICE_ROLE_KEY=
   SESSION_SECRET= # for cookie sessions
   ```

2. Create Supabase client utilities:
   - Server-side client (for loaders/actions)
   - Browser client (for client components)
   - Session management utilities

3. Set up TypeScript types for Supabase schema:
   - Use Supabase CLI to generate types: `supabase gen types typescript`
   - Save to `app/types/database.types.ts`

### 1.2 Authentication System

**Files to create:**

- `app/routes/auth.login.tsx` - Login page
- `app/routes/auth.register.tsx` - Registration page
- `app/routes/auth.callback.tsx` - OAuth callback handler
- `app/routes/auth.logout.tsx` - Logout action
- `app/lib/auth.server.ts` - Auth utility functions
- `app/lib/session.server.ts` - Session management

**Route definitions in `app/routes.ts`:**

```typescript
route("auth/login", "routes/auth.login.tsx"),
route("auth/register", "routes/auth.register.tsx"),
route("auth/callback", "routes/auth.callback.tsx"),
route("auth/logout", "routes/auth.logout.tsx"),
```

**Key features:**

1. **Login page** (`auth.login.tsx`):
   - Email/password form
   - Google OAuth button
   - Action handler for form submission
   - Loader checks if already authenticated → redirect to dashboard

2. **Register page** (`auth.register.tsx`):
   - Email/password/confirm form
   - Validation (min 8 chars password)
   - Google OAuth button
   - Action handler for registration
   - Success → redirect to dashboard

3. **OAuth callback** (`auth.callback.tsx`):
   - Handle Google OAuth redirect
   - Exchange code for session
   - Create session cookie
   - Redirect to dashboard

4. **Session management**:
   - Use `createCookieSessionStorage` from React Router
   - Store user session in encrypted cookie
   - Helper functions: `getUserSession`, `requireUserId`, `logout`

### 1.3 UI Components Setup (shadcn/ui)

**Install shadcn/ui:**

```bash
npx shadcn@latest init
```

**Components to install:**

```bash
npx shadcn@latest add button
npx shadcn@latest add input
npx shadcn@latest add label
npx shadcn@latest add card
npx shadcn@latest add dialog
npx shadcn@latest add dropdown-menu
npx shadcn@latest add select
npx shadcn@latest add textarea
npx shadcn@latest add toast
npx shadcn@latest add tabs
npx shadcn@latest add collapsible
npx shadcn@latest add avatar
npx shadcn@latest add badge
npx shadcn@latest add alert
```

**Files created by shadcn:**

- `components/ui/*` - shadcn components
- `lib/utils.ts` - cn() utility for className merging
- `components.json` - shadcn config

**Custom components to create:**

- `app/components/nav.tsx` - Navigation header
- `app/components/empty-state.tsx` - Empty state component
- `app/components/loading-spinner.tsx` - Loading indicator

### 1.4 Root Layout & Navigation

**Files to modify:**

- `app/root.tsx` - Add navigation, toast provider
- `app/app.css` - Customize Tailwind theme for accessibility

**Tasks:**

1. Update `root.tsx`:
   - Add navigation component (conditional based on auth)
   - Add Toaster component for notifications
   - Ensure proper ARIA landmarks

2. Update `app.css`:
   - High contrast color palette (WCAG 2.1 AA compliant)
   - Minimum 16px base font size
   - Focus visible styles for keyboard navigation

### 1.5 Protected Route Middleware

**Files to create:**

- `app/lib/require-auth.server.ts`

**Functionality:**

- Loader utility that checks authentication
- Redirects to `/auth/login` if not authenticated
- Returns user session if authenticated
- Used in all protected routes

---

## Phase 2: Core Plant Management

### 2.1 Dashboard Route

**Files to create:**

- `app/routes/dashboard.tsx` - Main dashboard layout
- `app/routes/dashboard._index.tsx` - Dashboard home (plant list)
- `app/components/plant-card.tsx` - Plant card component
- `app/components/add-plant-dialog.tsx` - Modal for choosing manual/AI

**Route definitions:**

```typescript
route("dashboard", "routes/dashboard.tsx", [
  index("routes/dashboard._index.tsx"),
  route("plants/new", "routes/dashboard.plants.new.tsx"),
  route("plants/:plantId", "routes/dashboard.plants.$plantId.tsx"),
  route("plants/:plantId/edit", "routes/dashboard.plants.$plantId.edit.tsx"),
]),
```

**Dashboard home (`dashboard._index.tsx`):**

- **Loader**: Fetch all plants for user, include last watering data
- **Component**:
  - Empty state if no plants
  - Grid of plant cards (responsive)
  - [+ Add Plant] button → opens dialog
  - Room filter chips (horizontal scroll)

**Plant card component:**

- Display: photo, name, room tag
- Status: "Last watered: X days ago | Next: in Y days"
- Click → navigate to plant details
- Calculate colors based on watering status (green/orange/red)

### 2.2 Manual Plant Creation

**Files to create:**

- `app/routes/dashboard.plants.new.tsx` - Create plant form
- `app/lib/image.server.ts` - Image upload/compression utilities
- `app/lib/plants.server.ts` - Plant CRUD utilities

**Form flow:**

1. File input for photo upload (optional)
2. Text input for plant name (required)
3. Number input for watering frequency (required)
4. Select dropdown for room (optional, with "Create new" option)
5. Submit button

**Action handler:**

1. Parse `FormData`
2. Validate inputs
3. If photo provided:
   - Get file from FormData
   - Compress using Sharp library (500KB, 1920px max)
   - Upload to Supabase Storage at `{userId}/{uuid}.jpg`
   - Get public URL
4. If new room specified, create it first
5. Insert plant into database
6. Redirect to plant details page

**Server-side image processing (Sharp):**

```typescript
// app/lib/image.server.ts
import sharp from 'sharp';

export async function compressImage(
  buffer: Buffer,
  maxWidth = 1920,
  maxSizeKB = 500
): Promise<Buffer> {
  return sharp(buffer)
    .resize(maxWidth, null, { withoutEnlargement: true })
    .jpeg({ quality: 85, progressive: true })
    .toBuffer();
}
```

### 2.3 Plant Details View

**Files to create:**

- `app/routes/dashboard.plants.$plantId.tsx` - Plant details page

**Loader:**

- Fetch plant by ID
- Ensure user owns the plant (RLS handles this)
- Fetch watering history (last 10 entries)
- Calculate last watered date and next watering date
- Return 404 if not found

**Component:**

- Large photo display
- Plant name (heading)
- Room tag (badge)
- Watering status with color coding
- [Watered Today] button (prominent, 44px+ height)
- Collapsible sections:
  - Light Requirements (always open)
  - Fertilizing Tips (collapsible)
  - Pruning Tips (collapsible)
  - Troubleshooting (collapsible)
- Watering History section (last 10, formatted dates)
- [Edit] and [Delete] buttons at bottom

**Action handler (for "Watered Today" button):**

1. Insert into `watering_history` table
2. Return success
3. Trigger toast notification
4. Revalidate loader data

### 2.4 Edit Plant

**Files to create:**

- `app/routes/dashboard.plants.$plantId.edit.tsx` - Edit form

**Loader:**

- Fetch plant data (same as details)
- Fetch all rooms for dropdown

**Component:**

- Pre-filled form with current values
- All fields editable (name, photo, frequency, room, care instructions)
- [Save Changes] and [Cancel] buttons

**Action handler:**

- Parse FormData
- If new photo uploaded, compress and replace old one
- Update plant record in database
- Redirect to plant details with success message

### 2.5 Delete Plant

**Implement in plant details route:**

- Add delete action handler
- Show confirmation dialog (client-side)
- On confirm, submit form with intent="delete"
- Action: Delete plant from database (cascade deletes watering history)
- Redirect to dashboard with success toast

---

## Phase 3: Watering System

### 3.1 Watering Tracking

**Already implemented in Phase 2.3**, but enhance:

**Create utility function:**

```typescript
// app/lib/watering.server.ts
export async function markAsWatered(plantId: string, userId: string) {
  // Insert watering record
  // Return updated next watering date
}

export async function getWateringHistory(plantId: string, limit = 10) {
  // Fetch last N watering events
}

export async function calculateNextWateringDate(plantId: string) {
  // Query last watering + frequency
  // Return calculated date
}
```

### 3.2 Notifications Modal

**Files to create:**

- `app/routes/api.notifications.tsx` - API route for notifications data
- `app/components/notifications-modal.tsx` - Modal component

**API route loader:**

- Fetch all plants where `next_watering_date <= NOW()`
- Calculate days overdue for each
- Return sorted by urgency (most overdue first)

**Modal component:**

- Trigger: Bell icon in navigation (show badge with count)
- Display list of plants needing water
- Each item:
  - Photo thumbnail
  - Plant name
  - Status text: "Due today" or "Overdue by X days"
  - Color coding (orange/red/dark red)
  - [Watered] button
- Click plant item → navigate to details
- [x] button → close modal

**Watered button action:**

- Call API to mark as watered
- Remove from notification list (optimistic UI)
- Show success feedback

### 3.3 Notification Badge

**Files to modify:**

- `app/components/nav.tsx` - Add bell icon with badge

**Implementation:**

- Loader in dashboard layout fetches notification count
- Display count badge on bell icon if > 0
- Click → open notifications modal

---

## Phase 4: AI Integration

### 4.1 Mocked API Services

**Files to create:**

- `app/lib/plantnet.server.ts` - PlantNet API wrapper (mocked)
- `app/lib/openai.server.ts` - GPT-5 API wrapper (mocked)

**PlantNet mock:**

```typescript
export async function identifyPlant(imageUrl: string): Promise<{
  scientificName: string;
  commonNames: string[];
  confidence: number;
}> {
  // Mock delay
  await new Promise((resolve) => setTimeout(resolve, 2000));

  // Return mock data
  return {
    scientificName: 'Monstera deliciosa',
    commonNames: ['Monstera', 'Swiss Cheese Plant'],
    confidence: 0.92,
  };
}
```

**OpenAI mock:**

```typescript
export async function generateCareInstructions(plantName: string): Promise<{
  wateringFrequencyDays: number;
  lightRequirements: string;
  fertilizingTips: string[];
  pruningTips: string[];
  troubleshooting: string[];
}> {
  // Mock delay
  await new Promise((resolve) => setTimeout(resolve, 3000));

  // Return mock data based on plant name
  return {
    wateringFrequencyDays: 7,
    lightRequirements: 'Bright indirect light, 6-8 hours daily',
    fertilizingTips: [
      'Fertilize every 4-6 weeks during growing season',
      'Use balanced liquid fertilizer diluted to half strength',
      'Reduce fertilizing in fall and winter',
    ],
    pruningTips: [
      'Prune yellow or damaged leaves at the base',
      'Trim aerial roots if they become unruly',
      'Best time to prune is in spring or early summer',
    ],
    troubleshooting: [
      'Yellow leaves: Overwatering or too much direct sun',
      'Brown leaf tips: Low humidity or underwatering',
      'Pests: Check for spider mites and mealybugs',
    ],
  };
}
```

### 4.2 AI Plant Creation Flow

**Files to create:**

- `app/routes/dashboard.plants.new-ai.tsx` - AI creation wizard
- `app/components/ai-creation-steps.tsx` - Multi-step wizard component
- `app/components/ai-feedback-dialog.tsx` - Feedback modal

**Flow steps:**

**Step 1: Upload Photo**

- File input
- Preview uploaded image
- [Continue] button

**Step 2: Identify Plant**

- Show loading state: "Identifying plant..." (spinner)
- Call PlantNet API (mocked)
- Display result: Photo + "Is this [Plant Name]?"
- [Yes] or [No, enter name manually] buttons

**Step 3: Manual Name Fallback (if No clicked)**

- Text input for plant name
- [Continue] button (disabled if empty)

**Step 4: Generate Care Instructions**

- Show loading state: "Generating care instructions..." (spinner)
- Call GPT-5 API (mocked) with plant name
- Display preview of all generated data

**Step 5: Preview & Edit**

- Show all fields (name, photo, frequency, room, care sections)
- All fields editable
- [Accept] button (saves as-is) or [Edit] (make inline edits)
- [Save] button after editing

**Step 6: AI Feedback Modal**

- After saving, show feedback dialog
- Thumbs up / Thumbs down buttons
- Optional textarea for comments (max 500 chars)
- [Submit Feedback] or [Skip] buttons
- Save feedback to `ai_feedback` table with AI response snapshot

**Action handler:**

1. Handle each step's form submission
2. Store progress in session or URL params
3. On final save:
   - Compress and upload photo
   - Insert plant with `created_with_ai = true`
   - Store AI response snapshot
   - Redirect to feedback modal
4. After feedback, redirect to plant details

### 4.3 Usage Limits Tracking

**Files to create:**

- `app/lib/usage-limits.server.ts` - Usage tracking utilities

**Functions:**

```typescript
export async function checkAIGenerationLimit(userId: string): Promise<{
  allowed: boolean;
  used: number;
  limit: number;
  resetsOn: Date;
}> {
  // Check current month's usage
  // Return limit status
}

export async function incrementAIUsage(userId: string): Promise<void> {
  // Increment counter for current month
  // Create record if doesn't exist
}

export async function checkPlantLimit(userId: string): Promise<{
  allowed: boolean;
  count: number;
  limit: number;
}> {
  // Count user's plants
  // Return whether they can add more
}
```

**Integration:**

- Check limits before allowing AI creation
- Check plant limit before any creation (manual or AI)
- Display friendly error messages if limit reached
- Show usage stats in settings (future)

---

## Phase 5: Organization & Polish

### 5.1 Rooms Management

**Files to create:**

- `app/routes/api.rooms.tsx` - CRUD API for rooms

**Features:**

**Create room:**

- Inline input in dashboard filter chips
- API endpoint to create room
- Return new room, update UI

**Assign room to plant:**

- Dropdown in create/edit forms
- Option to create new room inline
- Update plant record

**Filter by room:**

- Horizontal scrolling chip filter
- Single-select (only one active)
- Update URL params: `?room={roomId}`
- Dashboard loader reads URL param and filters plants
- Bookmark-friendly URLs

### 5.2 Accessibility Audit

**Tasks:**

1. **Color contrast audit**:
   - Use tools like WebAIM Contrast Checker
   - Ensure 4.5:1 ratio for all text
   - Don't rely on color alone for status (add icons)

2. **Touch target sizes**:
   - All interactive elements minimum 44x44px
   - Add padding to small buttons

3. **Keyboard navigation**:
   - Test all flows with keyboard only
   - Ensure visible focus indicators
   - Trap focus in modals
   - Escape key closes modals

4. **Screen reader testing**:
   - Add proper ARIA labels
   - Ensure form labels are associated
   - Use semantic HTML (nav, main, section)

5. **Language clarity**:
   - Review all button labels (action-oriented)
   - Review all instructions (concrete, specific)
   - No jargon or ambiguous terms

### 5.3 Error Handling & Validation

**Files to create:**

- `app/components/form-error.tsx` - Form error display component
- `app/lib/validation.ts` - Validation utilities

**Implement:**

1. Client-side validation:
   - Required fields
   - Email format
   - Password strength
   - File size/type

2. Server-side validation:
   - Re-validate all inputs in actions
   - Return actionData with errors
   - Display errors in form

3. Error boundaries:
   - Enhance root error boundary
   - Add route-level error boundaries for specific cases

4. User-friendly error messages:
   - "Plant photo must be JPG or PNG" not "Invalid file type"
   - "Please enter a watering frequency between 1 and 365 days"

### 5.4 Loading States & Optimistic UI

**Implement:**

1. **Loading indicators**:
   - Use `useNavigation()` hook to show loading states
   - Skeleton loaders for data fetching
   - Spinner for AI operations

2. **Optimistic UI**:
   - "Watered Today" button shows instant feedback
   - Remove from notification list immediately
   - Revert if action fails

3. **Transitions**:
   - Smooth transitions between states
   - Loading bars for navigation

---

## Phase 6: Testing & Optimization

### 6.1 Unit Tests Setup

**Install dependencies:**

```bash
yarn add -D vitest @testing-library/react @testing-library/jest-dom @testing-library/user-event
```

**Files to create:**

- `vitest.config.ts` - Vitest configuration
- `app/test/setup.ts` - Test setup file
- `app/test/mocks/supabase.ts` - Supabase client mocks

**Configure Vitest:**

```typescript
import react from '@vitejs/plugin-react';
import tsconfigPaths from 'vite-tsconfig-paths';
import { defineConfig } from 'vitest/config';

export default defineConfig({
  plugins: [react(), tsconfigPaths()],
  test: {
    environment: 'jsdom',
    setupFiles: ['./app/test/setup.ts'],
  },
});
```

### 6.2 Unit Tests to Write

**Priority tests:**

1. **Utility functions:**
   - `app/lib/watering.server.test.ts` - Watering calculations
   - `app/lib/validation.test.ts` - Validation logic
   - `app/lib/usage-limits.server.test.ts` - Limit checks

2. **Components:**
   - `app/components/plant-card.test.tsx` - Plant card rendering
   - `app/components/notifications-modal.test.tsx` - Modal behavior
   - `app/components/nav.test.tsx` - Navigation rendering

3. **Route actions/loaders** (integration-style):
   - Test action handlers with mocked Supabase
   - Test loader data fetching
   - Test error cases

**Example test:**

```typescript
// app/lib/watering.server.test.ts
import { describe, expect, it } from 'vitest';

import { calculateNextWateringDate } from './watering.server';

describe('calculateNextWateringDate', () => {
  it('calculates correct next date from last watering', () => {
    const lastWatered = new Date('2025-01-01');
    const frequency = 7;
    const expected = new Date('2025-01-08');

    const result = calculateNextWateringDate(lastWatered, frequency);
    expect(result).toEqual(expected);
  });
});
```

### 6.3 Performance Optimization

**Tasks:**

1. **Image optimization**:
   - Ensure all images are compressed
   - Use WebP format where supported
   - Lazy load images below fold

2. **Code splitting**:
   - React Router handles route-based splitting automatically
   - Lazy load heavy components (e.g., AI wizard)

3. **Database query optimization**:
   - Use indexes (already defined in schema)
   - Limit query results (e.g., last 10 watering events)
   - Avoid N+1 queries (use joins/includes)

4. **Caching**:
   - Cache-Control headers for static assets
   - Consider caching dashboard data (short TTL)

5. **Lighthouse audit**:
   - Run audit on key pages
   - Target >80 score
   - Fix any critical issues

### 6.4 Documentation

**Files to create:**

- Update `CLAUDE.md` with implementation details
- Create `DEPLOYMENT.md` - Deployment instructions
- Create `TESTING.md` - Testing guide

**CLAUDE.md additions:**

- Database schema overview
- Key architectural decisions
- How to run tests
- How to add new routes/features

---

## Critical Files Summary

### Configuration Files

- `.env` - Environment variables (Supabase, API keys)
- `vite.config.ts` - Vite + React Router config
- `react-router.config.ts` - SSR settings
- `tsconfig.json` - TypeScript config
- `vitest.config.ts` - Test configuration
- `components.json` - shadcn/ui config

### Core Application Files

- `app/root.tsx` - Root layout, navigation, providers
- `app/routes.ts` - Route definitions
- `app/app.css` - Global styles, Tailwind customizations

### Authentication & Session

- `app/lib/supabase.server.ts` - Server Supabase client
- `app/lib/supabase.client.ts` - Browser Supabase client
- `app/lib/auth.server.ts` - Auth utilities
- `app/lib/session.server.ts` - Session management
- `app/routes/auth.login.tsx` - Login page
- `app/routes/auth.register.tsx` - Registration page
- `app/routes/auth.callback.tsx` - OAuth callback
- `app/routes/auth.logout.tsx` - Logout action

### Plant Management

- `app/routes/dashboard.tsx` - Dashboard layout
- `app/routes/dashboard._index.tsx` - Plant list/dashboard home
- `app/routes/dashboard.plants.new.tsx` - Manual plant creation
- `app/routes/dashboard.plants.new-ai.tsx` - AI plant creation wizard
- `app/routes/dashboard.plants.$plantId.tsx` - Plant details
- `app/routes/dashboard.plants.$plantId.edit.tsx` - Edit plant
- `app/lib/plants.server.ts` - Plant CRUD utilities
- `app/lib/image.server.ts` - Image processing (Sharp)

### Watering System

- `app/lib/watering.server.ts` - Watering utilities
- `app/routes/api.notifications.tsx` - Notifications API
- `app/components/notifications-modal.tsx` - Notifications UI

### AI Integration

- `app/lib/plantnet.server.ts` - PlantNet API wrapper (mocked)
- `app/lib/openai.server.ts` - GPT-5 API wrapper (mocked)
- `app/components/ai-creation-steps.tsx` - AI wizard
- `app/components/ai-feedback-dialog.tsx` - Feedback modal

### Organization & Limits

- `app/routes/api.rooms.tsx` - Rooms CRUD API
- `app/lib/usage-limits.server.ts` - Usage tracking

### Components (UI)

- `app/components/ui/*` - shadcn/ui components
- `app/components/nav.tsx` - Navigation
- `app/components/plant-card.tsx` - Plant card
- `app/components/add-plant-dialog.tsx` - Add plant modal
- `app/components/loading-spinner.tsx` - Loading indicator
- `app/components/empty-state.tsx` - Empty state
- `app/components/form-error.tsx` - Form errors

### Types & Utilities

- `app/types/database.types.ts` - Supabase generated types
- `app/lib/utils.ts` - General utilities (cn, etc.)
- `app/lib/validation.ts` - Form validation

---

## Verification & Testing Plan

### End-to-End Verification Workflow

**1. Authentication Flow**

- [ ] Visit app → redirected to login
- [ ] Register new account (email/password)
- [ ] Logout and login again
- [ ] Test Google OAuth registration
- [ ] Verify session persists across page reloads

**2. Manual Plant Creation**

- [ ] Create plant without photo (name + frequency)
- [ ] Create plant with photo upload
- [ ] Verify photo is compressed and displayed
- [ ] Edit plant details
- [ ] Delete plant with confirmation

**3. Watering System**

- [ ] Create plant with 1-day frequency
- [ ] Wait for next day (or manually set date in DB)
- [ ] Verify notification badge shows count
- [ ] Open notifications modal
- [ ] Verify plant shows as overdue
- [ ] Mark as watered
- [ ] Verify notification cleared
- [ ] Check watering history on plant details

**4. AI Plant Creation** (with mocks)

- [ ] Click "Add Plant" → "Use AI"
- [ ] Upload photo
- [ ] Verify identification loading state (2s)
- [ ] Verify plant name displayed
- [ ] Click "Yes, that's my plant"
- [ ] Verify care instructions loading (3s)
- [ ] Verify preview shows all data
- [ ] Click "Accept"
- [ ] Submit feedback (thumbs up/down)
- [ ] Verify plant saved with AI flag
- [ ] Verify feedback saved to database

**5. Rooms/Organization**

- [ ] Create new room via chip filter
- [ ] Assign plants to rooms
- [ ] Filter dashboard by room
- [ ] Verify URL param updates
- [ ] Bookmark URL and verify filter persists

**6. Usage Limits**

- [ ] Create 50 plants (or set limit in code to 3 for testing)
- [ ] Verify "Add Plant" disabled when limit reached
- [ ] Use AI 20 times (or set limit to 3)
- [ ] Verify AI option disabled when limit reached
- [ ] Verify limit resets next month

**7. Accessibility**

- [ ] Navigate entire app with keyboard only
- [ ] Verify focus indicators visible
- [ ] Test with screen reader (basic)
- [ ] Run axe DevTools audit
- [ ] Verify high contrast mode works
- [ ] Test on mobile (375px width)

**8. Performance**

- [ ] Run Lighthouse audit on dashboard
- [ ] Verify score >80 on all metrics
- [ ] Test with 50 plants on dashboard
- [ ] Verify smooth scrolling and rendering

**9. Unit Tests**

- [ ] Run `yarn test` and verify all pass
- [ ] Check test coverage report
- [ ] Ensure critical utilities have >80% coverage

**10. Error Handling**

- [ ] Test form validation (empty fields, invalid email)
- [ ] Test upload with invalid file type
- [ ] Test upload with >10MB file
- [ ] Test deleting plant from another user (should fail via RLS)
- [ ] Disconnect internet and verify error messages

---

## Estimated Effort

**Phase 1: Foundation (Week 1-2)** - 10-15 hours
**Phase 2: Core Plant Management (Week 3-4)** - 20-25 hours
**Phase 3: Watering System (Week 5-6)** - 15-20 hours
**Phase 4: AI Integration (Week 7-9)** - 20-25 hours
**Phase 5: Organization & Polish (Week 10-11)** - 15-20 hours
**Phase 6: Testing & Optimization (Week 12-14)** - 15-20 hours

**Total:** ~95-125 hours (12-16 weeks at 8 hours/week)

This aligns with the PRD timeline of 10-14 weeks with 1 full-time developer.
